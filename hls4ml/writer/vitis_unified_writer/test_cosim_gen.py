import os
from meta import VitisUnifiedWriterMeta
import meta_gen as mg

def write_wrapper_test(meta, model):

    filedir = os.path.dirname(os.path.abspath(__file__))
    f    = open(os.path.join(filedir, '../templates/vitis_unified/myproject_test.cpp'))
    fout = open(f'{model.config.get_output_dir()}/{model.config.get_project_name()}_test.cpp', 'w')

    model_inputs  = model.get_input_variables()
    model_outputs = model.get_output_variables()
    model_brams = [var for var in model.get_weight_variables() if var.storage.lower() == 'bram']

    fout.write("//// generated by partial backend\n")

    for line in f.readlines():
        indent = ' ' * (len(line) - len(line.lstrip(' ')))

        #Insert numbers
        if 'myproject' in line:
            newline = line.replace('myproject', model.config.get_project_name())
        elif '// hls-fpga-machine-learning insert bram' in line:
            newline = line
            for bram in model_brams:
                newline += f'#include \"firmware/weights/{bram.name}.h\"\n'

        elif '// hls-fpga-machine-learning insert data' in line:
            newline = line
            offset = 0
            for inputIdx, inp in enumerate(model_inputs):
                streamPktType = mg.get_axi_wrapper_type(inp) if meta.vitis_unified_config.isFreeInterimInput() else mg.getDmaTypeName()

                newline += "      hls::stream<{desType}> {inputPortName};\n".format(
                    desType = streamPktType, inputPortName = mg.getWrapperPortName(inp, True)
                )
                if meta.vitis_unified_config.isFreeInterimInput():
                    newline += '      nnet::copy_data_axi_w_offset<float, {underlyType}, {wrapType}, {offset}, {inputSize}>(in, {inputPortName});\n'.format(
                        underlyType = inp.type.name,
                        wrapType=streamPktType,
                        offset=offset,
                        inputSize=str(inp.size()),
                        inputPortName=mg.getWrapperPortName(inp, True)
                    )
                else:
                    newline += '      nnet::copy_data_axi_w_offset<float, {destype}, {offset}, {inputSize}>(in, {inputPortName});\n'.format(
                        destype = streamPktType, offset=offset, inputSize=str(inp.size()),
                        inputPortName=mg.getWrapperPortName(inp, True)
                    )
                offset += inp.size()
            for out in model_outputs:
                streamPktType = mg.get_axi_wrapper_type(out) if meta.vitis_unified_config.isFreeInterimOutput() else mg.getDmaTypeName()
                newline += '      ' + f"hls::stream<{streamPktType}> {mg.getWrapperPortName(out, False)};\n"

        elif '// hls-fpga-machine-learning insert top-level-function' in line:
            newline = line

            input_vars  = ','.join([mg.getWrapperPortName(inp, True) for inp in model_inputs])
            output_vars = ','.join([mg.getWrapperPortName(out, False) for out in model_outputs])
            bram_vars   = ','.join([b.name for b in model_brams])

            # Concatenate the input, output, and bram variables. Filter out empty/null values
            all_vars = ','.join(filter(None, [input_vars, output_vars, bram_vars]))

            top_level = indent + f'{mg.getTopModelName(model)}({all_vars});\n'

            newline += top_level
        elif '// hls-fpga-machine-learning insert predictions' in line:
            newline = line
            for outIdx, out in enumerate(model_outputs):
                #newline += indent + f'for(int i = 0; i < {out.size_cpp()}; i++) {{\n'
                newline += indent + f'for(int i = 0; i < {mg.get_outputSizeArrName(model)}[{outIdx}]; i++) {{\n'
                newline += indent + '  std::cout << pr[i] << " ";\n'
                newline += indent + '}\n'
                newline += indent + 'std::cout << std::endl;\n'
        # elif '// hls-fpga-machine-learning insert tb-output' in line:
        #     newline = line
        #     tb_stream = model.config.get_writer_config().get('TBOutputStream', 'both')
        #     if tb_stream != 'stdout':
        #         for outIdx, out in enumerate(model_outputs):
        #             # newline += indent + 'nnet::print_result<{}, {}>({}, fout);\n'.format(
        #             #     out.type.name, out.size_cpp(), out.name
        #             # )  # TODO enable this
        #             newline += indent + 'nnet::print_result<{actualType}, {dmaType}, {arrName}[{arrSize}]>({portName}, fout);\n'.format(
        #                 actualType = out.type.name, dmaType = mg.getDmaTypeName(), arrName = mg.get_outputSizeArrName(model),arrSize = str(outIdx), portName = mg.getWrapperPortName(out, False)
        #             )  # TODO enable this
        elif '// hls-fpga-machine-learning insert zero' in line:
            newline = line
            for inpIdx, inp in enumerate(model_inputs):
                streamPktType = mg.get_axi_wrapper_type(inp) if meta.vitis_unified_config.isFreeInterimInput() else mg.getDmaTypeName()
                fillZeroFunc  = "fill_zero_toArr" if meta.vitis_unified_config.isFreeInterimInput() else "fill_zero"
                newline += "        " + f"hls::stream<{streamPktType}> {mg.getWrapperPortName(inp, True)};\n"
                newline += "        " + (f'nnet::{fillZeroFunc}<{inp.type.name}, {streamPktType},{mg.get_inputSizeArrName(model)}[{str(inpIdx)}]>'
                                         f'({mg.getWrapperPortName(inp,True)});\n')
            for out in model_outputs:
                #newline += indent + out.definition_cpp() + ';\n'
                streamPktType = mg.get_axi_wrapper_type(out) if meta.vitis_unified_config.isFreeInterimOutput() else mg.getDmaTypeName()
                newline += "        " + f"hls::stream<{streamPktType}> {mg.getWrapperPortName(out, False)};\n"

        elif (
               '// hls-fpga-machine-learning insert output'    in line
            or '// hls-fpga-machine-learning insert quantized' in line
            or '// hls-fpga-machine-learning insert tb-output' in line
        ):
            newline = line
            tb_stream = model.config.get_writer_config().get('TBOutputStream', 'both')
            dest =  'fout' if ((tb_stream == 'file') or ('// hls-fpga-machine-learning insert tb-output' in line) ) else 'std::cout'
            keep_output = "true" if ("// hls-fpga-machine-learning insert tb-output" in line) else "false"
            #keep_output = str(tb_stream != 'stdout').lower()  # We keep output if we need to write it to file too.
            if tb_stream != 'file': ### it mean cout
                for outIdx, out in enumerate(model_outputs):
                    #     newline += indent + 'nnet::print_result<{}, {}>({}, std::cout, {});\n'.format(
                    #         out.type.name, out.size_cpp(), out.name, keep_output
                    #     )
                    streamPktType = mg.get_axi_wrapper_type(out) if meta.vitis_unified_config.isFreeInterimOutput() else mg.getDmaTypeName()

                    newline += (indent + 'nnet::print_result<{actualType}, {pktType}, {arrName}[{arrIdx}]>({portName}, {des}, {keepOutput});\n'
                                .format( actualType = out.type.name,
                                         pktType    = streamPktType,
                                         arrName    = mg.get_outputSizeArrName(model),
                                         arrIdx     = str(outIdx),
                                         portName   = mg.getWrapperPortName(out, False),
                                         des        = dest,
                                         keepOutput = keep_output))

        elif '// hls-fpga-machine-learning insert namespace' in line:
            newline = ''

            namespace = model.config.get_writer_config().get('Namespace', None)
            if namespace is not None:
                newline += indent + f'using namespace {namespace};\n'

        else:
            newline = line

        fout.write(newline)
    f.close()
    fout.close()


    ####################################################
    ### write myproject_bridge.cpp #####################
    ####################################################
    filedir = os.path.dirname(os.path.abspath(__file__))
    f = open(os.path.join(filedir, '../templates/vitis_unified/myproject_bridge.cpp'))
    fout = open(f'{model.config.get_output_dir()}/{model.config.get_project_name()}_bridge.cpp', 'w')

    model_inputs = model.get_input_variables()
    model_outputs = model.get_output_variables()
    model_brams = [var for var in model.get_weight_variables() if var.storage.lower() == 'bram']

    indent = '    '

    for line in f.readlines():
        if 'MYPROJECT' in line:
            newline = line.replace('MYPROJECT', format(model.config.get_project_name().upper()))

        elif 'myproject' in line:
            newline = line.replace('myproject', format(model.config.get_project_name()))

        elif '// hls-fpga-machine-learning insert bram' in line:
            newline = line
            for bram in model_brams:
                newline += f'#include \"firmware/weights/{bram.name}.h\"\n'

        elif '// hls-fpga-machine-learning insert header' in line:
            dtype = line.split('#', 1)[1].strip()
            inputs_str = ', '.join([f'{dtype} {i.name}[{i.size_cpp()}]' for i in model_inputs])
            outputs_str = ', '.join([f'{dtype} {o.name}[{o.size_cpp()}]' for o in model_outputs])

            newline = ''
            newline += indent + inputs_str + ',\n'
            newline += indent + outputs_str + '\n'

        elif '// hls-fpga-machine-learning insert wrapper' in line:
            dtype = line.split('#', 1)[1].strip()
            newline = ''
            for inpIdx, inp in enumerate(model_inputs): ## former is i
                if meta.vitis_unified_config.isFreeInterimInput():
                    newline += indent + f"hls::stream<{inp.type.name}> {mg.getWrapperPortName(inp, True)};\n"
                    newline += indent + "nnet::convert_data_pkt<{srcType}, {underlying_data_T}, {data_T}, {sz}>({inpRaw}, {inp_wrapper});\n".format(
                        srcType           =dtype,
                        underlying_data_T=inp.type.name,
                        data_T=mg.get_axi_wrapper_type(inp),
                        sz=str(inp.size()),
                        inpRaw=inp.name,
                        inp_wrapper=mg.getWrapperPortName(inp, True),
                    )
                else:
                    newline += indent + f"hls::stream<dma_data_packet> {mg.getWrapperPortName(inp, True)};\n"
                    newline += indent + f"nnet::convert_data<{dtype}, {dtype}, {mg.get_inputSizeArrName(model)}[{str(inpIdx)}]>({inp.name}, {mg.getWrapperPortName(inp, True)});\n"
                # newline += indent + '{var};\n'.format(var=i.definition_cpp(name_suffix='_ap'))
                # newline += indent + 'nnet::convert_data<{}, {}, {}>({}, {}_ap);\n'.format(
                #     dtype, i.type.name, i.size_cpp(), i.name, i.name
                # )
            newline += '\n'

            for out in model_outputs:
                #newline += indent + '{var};\n'.format(var=o.definition_cpp(name_suffix='_ap'))
                outStreamType = mg.get_axi_wrapper_type(out) if meta.vitis_unified_config.isFreeInterimOutput() else mg.getDmaTypeName()
                newline += indent + f"hls::stream<{outStreamType}> {mg.getWrapperPortName(out, False)};\n"

            newline += '\n'

            input_vars = ','.join([mg.getWrapperPortName(inp, True)for inp in model_inputs])
            bram_vars = ','.join([b.name for b in model_brams])
            output_vars = ','.join([mg.getWrapperPortName(out, False) for out in model_outputs])

            # Concatenate the input, output, and bram variables. Filter out empty/null values
            all_vars = ','.join(filter(None, [input_vars, output_vars, bram_vars]))

            top_level = indent + f'{mg.getTopModelName(model)}({all_vars});\n'
            newline += top_level

            newline += '\n'

            for outIdx, out in enumerate(model_outputs):
                # newline += indent + 'nnet::convert_data<{}, {}, {}>({}_ap, {});\n'.format(
                #     o.type.name, dtype, o.size_cpp(), o.name, o.name
                # )
                if meta.vitis_unified_config.isFreeInterimOutput():
                    newline += indent + f"nnet::convert_data_pkt<{dtype}, {out.type.name}, {mg.get_outputSizeArrName(model)}[{str(outIdx)}]>({mg.getWrapperPortName(out, False)}, {out.name});\n"
                else:
                    newline += indent + (f"nnet::convert_data<{dtype}, {dtype}, {mg.get_axi_wrapper_type(out)},{mg.get_outputSizeArrName(model)}[{str(outIdx)}]>"
                                         f"({mg.getWrapperPortName(out, False)}, {out.name});\n")

        elif '// hls-fpga-machine-learning insert trace_outputs' in line:
            newline = ''
            for layer in model.get_layers():
                func = layer.get_attr('function_cpp', None)
                if func and model.config.trace_output and layer.get_attr('trace', False):
                    vars = layer.get_variables()
                    for var in vars:
                        newline += (
                                indent
                                + 'nnet::trace_outputs->insert(std::pair<std::string, void *>('
                                + f'"{layer.name}", (void *) malloc({var.size_cpp()} * element_size)));\n'
                        )

        elif '// hls-fpga-machine-learning insert namespace' in line:
            newline = ''

            namespace = model.config.get_writer_config().get('Namespace', None)
            if namespace is not None:
                newline += indent + f'using namespace {namespace};\n'

        else:
            newline = line
        fout.write(newline)

    f.close()
    fout.close()