import os
from .meta import VitisUnifiedWriterMeta
from . import meta_gen as mg

def write_wrapper_test(meta, model):


    #### warning we have to fix to float because the system locked by template
    inp_gmem_t, out_gmem_t, inps, outs = meta.vitis_unified_config.get_corrected_types()

    filedir = os.path.dirname(os.path.abspath(__file__))
    f    = open(os.path.join(filedir, '../../templates/vitis_unified/myproject_test.cpp'))
    fout = open(f'{model.config.get_output_dir()}/{model.config.get_project_name()}_test.cpp', 'w')

    model_inputs  = model.get_input_variables()
    model_outputs = model.get_output_variables()
    model_brams = [var for var in model.get_weight_variables() if var.storage.lower() == 'bram']

    fout.write("//// generated by partial backend\n")

    for line in f.readlines():
        indent = ' ' * (len(line) - len(line.lstrip(' ')))

        #Insert numbers
        if 'myproject' in line:
            newline = line.replace('myproject', model.config.get_project_name())
        elif '// hls-fpga-machine-learning insert bram' in line:
            newline = line
            for bram in model_brams:
                newline += f'#include \"firmware/weights/{bram.name}.h\"\n'

        elif '// hls-fpga-machine-learning insert data' in line:
            newline = line
            offset = 0
            for inputIdx, inp in enumerate(model_inputs):
                ##### input should be float
                newline += '        float* {inputPortName} = &in[{startIdx}];\n'.format( ### can not be double because it fix by template
                    inputPortName=mg.getGmemIOPortName(inp, True, inputIdx),
                    startIdx=str(offset)
                )
                offset += inp.size()
            for outputIdx, out in enumerate(model_outputs):
                newline += f"      float {mg.getGmemIOPortName(out, False, outputIdx)}[{out.size()}];\n"


        elif '// hls-fpga-machine-learning insert top-level-function' in line:
            newline = line

            input_ios  = []
            output_ios = []
            bram_ios   = [b.name for b in model_brams]

            for inpIdx, inp in enumerate(model_inputs):
                input_ios.append(mg.getGmemIOPortName(inp, True, inpIdx))
                input_ios.append(str(inp.size()))

            for outIdx, out in enumerate(model_outputs):
                output_ios.append(mg.getGmemIOPortName(out, False, outIdx))
                output_ios.append(str(out.size()))

            # Concatenate the input, output, and bram variables. Filter out empty/null values
            all_vars = ','.join(filter(None, [*input_ios, *output_ios, *bram_ios]))
            top_level = indent + f'{mg.getGemTopFuncName(model)}({all_vars});\n'
            newline += top_level

        elif '// hls-fpga-machine-learning insert predictions' in line:
            newline = line
            for outIdx, out in enumerate(model_outputs):
                #newline += indent + f'for(int i = 0; i < {out.size_cpp()}; i++) {{\n'
                newline += indent + f'for(int i = 0; i < {mg.get_outputSizeArrName(model)}[{outIdx}]; i++) {{\n'
                newline += indent + '  std::cout << pr[i] << " ";\n'
                newline += indent + '}\n'
                newline += indent + 'std::cout << std::endl;\n'
        elif '// hls-fpga-machine-learning insert zero' in line:
            newline = line
            for inpIdx, inp in enumerate(model_inputs):
                newline += indent + f'float {mg.getGmemIOPortName(inp, True, inpIdx)}[{str(inp.size())}] = {{}};\n'

            for outIdx, out in enumerate(model_outputs):
                newline += indent + f"float {mg.getGmemIOPortName(out, False, outIdx)}[{str(out.size())}] = {{}};\n"

        elif (
               '// hls-fpga-machine-learning insert output'    in line
            or '// hls-fpga-machine-learning insert quantized' in line
            or '// hls-fpga-machine-learning insert tb-output' in line
        ):

            newline = line
            tb_stream = model.config.get_writer_config().get('TBOutputStream', 'both')
            dest =  'fout' if ((tb_stream == 'file') or ('// hls-fpga-machine-learning insert tb-output' in line) ) else 'std::cout'
            keep_output = "true" if ("// hls-fpga-machine-learning insert tb-output" in line) else "false"
            newline += "/// warning keep is forced to be true\n"

            for outIdx, out in enumerate(model_outputs):
                newline += (indent + 'nnet::print_result<{actualType}, {arrName}[{arrIdx}]>({portName}, {des}, {keepOutput});\n'
                            .format( actualType = "float",
                                     arrName    = mg.get_outputSizeArrName(model),
                                     arrIdx     = str(outIdx),
                                     portName   = mg.getGmemIOPortName(out, False, outIdx),
                                     des        = dest,
                                     keepOutput = keep_output))

        elif '// hls-fpga-machine-learning insert namespace' in line:
            newline = ''

            namespace = model.config.get_writer_config().get('Namespace', None)
            if namespace is not None:
                newline += indent + f'using namespace {namespace};\n'

        else:
            newline = line

        fout.write(newline)
    f.close()
    fout.close()
